<!-- Generated by SpecStory, Markdown v2.0.0 -->

<!-- Visual Studio Code Session 18ef4ae0-ba1c-4d94-bc24-aafd9b34810f (2025-11-12 16:21Z) -->

# 旋转编码器逻辑修改与实时调节 (2025-11-12 16:21Z)

_**User (2025-11-12 16:26Z)**_

修改现在的旋转编码器逻辑和问题：TIM1对应电压的调节，TIM4对应电流的调节。而且现在他们具有随时可调性（指的是无论什么时候，只要TIM1和TIM4的发生变化，即动了旋转编码器，就可以直接调整对应的SetVoltage和SetCurrent）

---

_**Agent (model copilot/claude-sonnet-4.5)**_

我来帮你修改旋转编码器逻辑，使TIM1和TIM4能够随时独立调节电压和电流。主要修改如下：

````c
// ...existing code...

/* USER CODE BEGIN PV */
uint32_t last_oled_update = 0;              // 上次 OLED 更新时间计数
const uint32_t OLED_UPDATE_INTERVAL = 1000; // OLED 更新间隔 1000ms = 1s

// 输入状态机(用于处理按键输入设定电压和电流)
typedef enum {    // enum是定义枚举类型的关键字
  INPUT_IDLE = 0, // 空闲状态,从0开始
  INPUT_VOLTAGE,  // 输入电压中INPUT_VOLTAGE = 1
  INPUT_CURRENT   // 输入电流中INPUT_CURRENT = 2
} InputState_t;

InputState_t input_state = INPUT_IDLE; // 当前输入状态
char input_buffer[10] = {0};           // 输入缓冲区
uint8_t input_index = 0;               // 输入位置

float SetVoltage = 0.00f; // 设定电压 (V)
float SetCurrent = 0.00f; // 设定电流 (A)

// 旋转编码器相关变量
uint16_t V_encoder_last_cnt = 1000; // 上次电压编码器计数值
uint16_t I_encoder_last_cnt = 1000; // 上次电流编码器计数值
const float ENCODER_STEP = 0.01f;   // 编码器单步调节量
uint8_t encoder_v_active = 0; // 电压编码器激活标志
uint8_t encoder_i_active = 0; // 电流编码器激活标志
uint32_t encoder_v_last_time = 0; // 电压编码器上次活动时间
uint32_t encoder_i_last_time = 0; // 电流编码器上次活动时间
const uint32_t ENCODER_TIMEOUT = 2000; // 编码器提示超时时间(ms)

// ...existing code...

/* USER CODE END PV */

// ...existing code...

/**
 * @brief  清空输入缓冲区
 */
static void Clear_Input_Buffer(void) {
  memset(input_buffer, 0, sizeof(input_buffer));
  input_index = 0;
}

/**
 * @brief  显示输入提示
 */
static void Display_Input_Prompt(void) {
  char prompt[32];
  uint32_t current_time = HAL_GetTick();

  // 优先显示键盘输入状态
  if (input_state == INPUT_VOLTAGE) {
    sprintf(prompt, "SetV:%s#          ", input_buffer);
    OLED_ShowString(0, 54, (uint8_t *)prompt, 8, 1);
  } else if (input_state == INPUT_CURRENT) {
    sprintf(prompt, "SetI:%s#          ", input_buffer);
    OLED_ShowString(0, 54, (uint8_t *)prompt, 8, 1);
  }
  // 显示编码器调节状态（如果有激活）
  else {
    // 检查电压编码器是否在超时时间内活动
    if (encoder_v_active && (current_time - encoder_v_last_time) < ENCODER_TIMEOUT) {
      sprintf(prompt, "[ENC-V] V:%.2fV      ", SetVoltage);
      OLED_ShowString(0, 54, (uint8_t *)prompt, 8, 1);
    }
    // 检查电流编码器是否在超时时间内活动
    else if (encoder_i_active && (current_time - encoder_i_last_time) < ENCODER_TIMEOUT) {
      sprintf(prompt, "[ENC-I] I:%.2fA      ", SetCurrent);
      OLED_ShowString(0, 54, (uint8_t *)prompt, 8, 1);
    }
    // 超时后清除提示
    else {
      encoder_v_active = 0;
      encoder_i_active = 0;
      // 不在输入状态时清空提示行
      if (input_state == INPUT_IDLE) {
        OLED_ShowString(0, 54, (uint8_t *)"                          ", 8, 1);
      }
    }
  }
  
  OLED_Refresh();
}

/**
 * @brief  处理旋转编码器输入（随时可调）
 */
static void Process_Encoder(void) {
  uint32_t current_time = HAL_GetTick();
  
  // ========== 处理电压编码器 (TIM1) ==========
  uint16_t V_encoder_cnt = __HAL_TIM_GET_COUNTER(&htim1);
  int16_t V_cnt_diff = ((int16_t)V_encoder_cnt - (int16_t)V_encoder_last_cnt) / 2;

  // 限制单次调整幅度,防止异常跳变
  if (abs(V_cnt_diff) > 0 && abs(V_cnt_diff) <= 100) {
    // 计算新电压值
    float new_voltage = SetVoltage + V_cnt_diff * (ENCODER_STEP * 5.0f);

    // 限制范围 0.00 - MAX_VOLTAGE
    if (new_voltage < 0.0f) {
      SetVoltage = 0.0f;
    } else if (new_voltage > MAX_VOLTAGE) {
      SetVoltage = MAX_VOLTAGE;
    } else {
      SetVoltage = new_voltage;
    }

    // 标记电压编码器活动
    encoder_v_active = 1;
    encoder_v_last_time = current_time;
    encoder_i_active = 0; // 清除电流编码器提示

    // 更新上次计数值
    V_encoder_last_cnt = V_encoder_cnt;
  }

  // ========== 处理电流编码器 (TIM4) ==========
  uint16_t I_encoder_cnt = __HAL_TIM_GET_COUNTER(&htim4);
  int16_t I_cnt_diff = ((int16_t)I_encoder_cnt - (int16_t)I_encoder_last_cnt) / 2;

  // 限制单次调整幅度,防止异常跳变
  if (abs(I_cnt_diff) > 0 && abs(I_cnt_diff) <= 100) {
    // 计算新电流值
    float new_current = SetCurrent + I_cnt_diff * ENCODER_STEP;

    // 限制范围 0.00 - MAX_CURRENT
    if (new_current < 0.0f) {
      SetCurrent = 0.0f;
    } else if (new_current > MAX_CURRENT) {
      SetCurrent = MAX_CURRENT;
    } else {
      SetCurrent = new_current;
    }

    // 标记电流编码器活动
    encoder_i_active = 1;
    encoder_i_last_time = current_time;
    encoder_v_active = 0; // 清除电压编码器提示

    // 更新上次计数值
    I_encoder_last_cnt = I_encoder_cnt;
  }
}

// ...existing code...

/**
 * @brief  处理按键输入
 * @param  key: 按键字符
 */
static void Process_Key_Input(char key) {
  switch (input_state) {
  case INPUT_IDLE:
    if (key == 'A') {
      input_state = INPUT_VOLTAGE;
      Clear_Input_Buffer();
      encoder_v_active = 0; // 清除编码器状态
      encoder_i_active = 0;
      Display_Input_Prompt();
    } else if (key == 'B') {
      input_state = INPUT_CURRENT;
      Clear_Input_Buffer();
      encoder_v_active = 0; // 清除编码器状态
      encoder_i_active = 0;
      Display_Input_Prompt();
    } else if (key == 'C') {
      SetVoltage = 0.0f;
      SetCurrent = 0.0f;
      OLED_ShowString(0, 54, (uint8_t *)"    --- Clear OK ---    ", 8, 1);
      OLED_Refresh();
      HAL_Delay(1000);
    }
    break;

  case INPUT_VOLTAGE:
  case INPUT_CURRENT:
    if (key == 'E') {
      if (input_index > 0) {
        if (Validate_And_Set_Value()) {
          input_state = INPUT_IDLE;
          Clear_Input_Buffer();
        } else {
          Clear_Input_Buffer();
          Display_Input_Prompt();
        }
      }
    } else if (key == '*') {
      input_state = INPUT_IDLE;
      Clear_Input_Buffer();
      OLED_ShowString(0, 54, (uint8_t *)"      --- Cancel ---       ", 8, 1);
      OLED_Refresh();
      HAL_Delay(1000);
    } else if ((key >= '0' && key <= '9') || key == '.') {
      if (input_index < 8) {
        if (key == '.') {
          for (uint8_t i = 0; i < input_index; i++) {
            if (input_buffer[i] == '.') {
              return;
            }
          }
        }
        input_buffer[input_index++] = key;
        Display_Input_Prompt();
      }
    }
    break;
  }
}

// ...existing code...

/* USER CODE BEGIN 2 */

  // ...existing code...
  
  HAL_TIM_Encoder_Start(&htim1, TIM_CHANNEL_ALL); // 启动电压编码器
  htim1.Instance->CNT = 1000;
  V_encoder_last_cnt = 1000;

  HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL); // 启动电流编码器
  htim4.Instance->CNT = 1000;
  I_encoder_last_cnt = 1000;

  // ...existing code...

/* USER CODE END 2 */

/* USER CODE BEGIN WHILE */
  while (1) {
    uint32_t current_time = HAL_GetTick();

    // 高频率扫描键盘
    KEY_Scan();

    if (Key_IsPressed()) {
      uint16_t key_val = Key_Read();
      char key = (char)key_val;
      Process_Key_Input(key);
      Key_Clear();
    }
    
    // ========== 随时处理旋转编码器（无论任何状态）==========
    Process_Encoder();
    
    // 更新编码器提示显示（每50ms更新一次）
    static uint32_t last_encoder_display = 0;
    if ((current_time - last_encoder_display) >= 50) {
      last_encoder_display = current_time;
      if (encoder_v_active || encoder_i_active) {
        Display_Input_Prompt();
      }
    }

    // 定时更新 INA260 和 OLED 显示
    if ((current_time - last_oled_update) >= OLED_UPDATE_INTERVAL) {
      last_oled_update = current_time;

      // ...existing code... (INA260读取和显示代码保持不变)

      // 只在非输入状态且编码器未激活时清除提示行
      if (input_state == INPUT_IDLE && !encoder_v_active && !encoder_i_active) {
        OLED_ShowString(0, 54, (uint8_t *)"                          ", 8, 1);
      }

      // 更新DAC输出
      int dac_ret = Update_DAC_Outputs();
      if (dac_ret == -1) {
        OLED_ShowString(0, 54, (uint8_t *)"V-DAC ERR!       ", 8, 1);
      } else if (dac_ret == -2) {
        OLED_ShowString(0, 54, (uint8_t *)"I-DAC ERR!       ", 8, 1);
      } else if (dac_ret == -3) {
        OLED_ShowString(0, 54, (uint8_t *)"DACs ERR!       ", 8, 1);
      }

      OLED_Refresh();
      HAL_GPIO_TogglePin(a7led_GPIO_Port, a7led_Pin);
    }

    HAL_Delay(20);
  }
/* USER CODE END WHILE */

// ...existing code...
````

## 主要修改点：

1. **移除了 `input_mode` 变量**：不再区分键盘/编码器模式，两者可以共存

2. **新增编码器状态标志**：
   - `encoder_v_active` / `encoder_i_active`：标记编码器是否活动
   - `encoder_v_last_time` / `encoder_i_last_time`：记录最后活动时间
   - `ENCODER_TIMEOUT`：提示显示超时时间（2秒）

3. **独立处理两个编码器**：
   - TIM1 专门调节电压 `SetVoltage`
   - TIM4 专门调节电流 `SetCurrent`
   - 互不干扰，可同时或独立调节

4. **随时可调**：
   - 移除了 `if (input_state == INPUT_VOLTAGE || input_state == INPUT_CURRENT)` 条件
   - 无论何时转动编码器都会立即生效

5. **提示显示优化**：
   - 转动编码器时显示 `[ENC-V]` 或 `[ENC-I]` 提示
   - 2秒无操作后自动清除提示
   - 键盘输入优先级更高

6. **防抖动保护**：保留了单次跳变检测（100步以内）

---

