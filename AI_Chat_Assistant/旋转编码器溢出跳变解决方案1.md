<!-- Generated by SpecStory, Markdown v2.0.0 -->

<!-- Visual Studio Code Session c486af2f-3ec3-4ae7-8acf-a7cbac189f51 (2025-11-03 15:19Z) -->

# 旋转编码器溢出跳变解决方案 (2025-11-03 15:19Z)

_**User (2025-11-03 15:22Z)**_

现在旋转编码器使用,比如往一个方向一致转让计数器溢出后,比如一直顺时针,会有16.00-->0.00的跳变,或者在中途突然出现比如7.65-->13.65的跳变,如何解决这种溢出跳变?

---

_**Agent (model copilot/claude-sonnet-4.5)**_

旋转编码器计数溢出问题的根本原因是 `encoder_last_cnt` 和 `encoder_cnt` 之间的差值计算在发生溢出时产生了错误的结果。

以下是解决方案:

````c
/**
 * @brief  处理旋转编码器输入
 */
static void Process_Encoder(void) {
  // 获取当前编码器计数值
  uint16_t encoder_cnt = __HAL_TIM_GET_COUNTER(&htim1);

  // 计算计数差值 - 使用有符号整数避免溢出问题
  // 方法1: 先转换为有符号数再相减
  int16_t cnt_diff = ((int16_t)encoder_cnt - (int16_t)encoder_last_cnt) / 2;
  
  // 方法2(更稳健): 处理溢出情况
  // int16_t raw_diff = (int16_t)encoder_cnt - (int16_t)encoder_last_cnt;
  // // 检测大幅跳变(可能是溢出)
  // if (raw_diff > 32767 || raw_diff < -32767) {
  //   // 忽略溢出的数据
  //   encoder_last_cnt = encoder_cnt;
  //   return;
  // }
  // int16_t cnt_diff = raw_diff / 2;

  // 如果计数值变化
  if (cnt_diff != 0) {
    // 限制单次调整幅度,防止异常跳变
    if (abs(cnt_diff) > 100) {
      // 单次变化过大,可能是溢出或干扰,忽略
      encoder_last_cnt = encoder_cnt;
      return;
    }

    // 切换到编码器模式,清空键盘缓冲区
    if (input_mode == 0) {
      input_mode = 1;
      memset(input_buffer, 0, sizeof(input_buffer));
      input_index = 0;
    }

    // 根据当前模式调节电压或电流
    if (input_state == INPUT_VOLTAGE) {
      // 调节电压模式
      float new_voltage = SetVoltage + cnt_diff * (ENCODER_STEP * 5.0f);

      // 限制范围 0.00 - 16.00 V
      if (new_voltage < 0.0f) {
        SetVoltage = 0.0f;
      } else if (new_voltage > MAX_VOLTAGE) {
        SetVoltage = MAX_VOLTAGE;
      } else {
        SetVoltage = new_voltage;
      }

    } else if (input_state == INPUT_CURRENT) {
      // 调节电流模式
      float new_current = SetCurrent + cnt_diff * ENCODER_STEP;

      // 限制范围 0.00 - 5.00 A
      if (new_current < 0.0f) {
        SetCurrent = 0.0f;
      } else if (new_current > MAX_CURRENT) {
        SetCurrent = MAX_CURRENT;
      } else {
        SetCurrent = new_current;
      }
    }

    // 更新上次计数值
    encoder_last_cnt = encoder_cnt;

    // 显示提示信息
    Display_Input_Prompt();
  }
}
````

**主要改进点:**

1. **正确的差值计算**: 先将 `uint16_t` 转换为 `int16_t` 再相减,避免无符号数相减导致的溢出
2. **异常跳变过滤**: 增加幅度检查,单次变化超过100则忽略(可根据实际情况调整阈值)
3. **先计算后限幅**: 先计算新值,再进行范围限制,避免中间过程的跳变

**可选增强方案**:

如果问题依然存在,可以考虑限制定时器计数范围,在初始化时添加:

````c
// ...existing code...
HAL_TIM_Encoder_Start(&htim1, TIM_CHANNEL_ALL); // 启动编码器接口
// 设置定时器自动重装载值,限制计数范围
htim1.Instance->ARR = 2000; // 设置合理的计数范围
htim1.Instance->CNT = 1000; // 初始化到中间值
encoder_last_cnt = 1000;
// ...existing code...
````

这样可以确保计数器在一个较小的范围内循环,减少溢出风险。

---

