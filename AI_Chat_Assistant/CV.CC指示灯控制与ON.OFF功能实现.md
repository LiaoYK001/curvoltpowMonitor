<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- Visual Studio Code Session 6c67f1fd-e61c-46ac-a549-2c47dafb5452 (2025-11-28 03:32Z) -->

# CV/CC 指示灯控制与 ON/OFF 功能实现 (2025-11-28 03:32Z)

_**User (2025-11-28 03:35Z)**_

添加CV和CC指示灯控制和ON/OFF控制.在ON条件下,恒流模式时候CC亮,恒压模式下CV亮

---

_**Agent (model copilot/claude-opus-4.5)**_

# CV/CC 指示灯和 ON/OFF 控制功能实现

根据您的需求，我将添加以下功能：
1. ON/OFF 状态控制输出
2. 恒压(CV)模式下 CV_LED 亮
3. 恒流(CC)模式下 CC_LED 亮
4. 只有在 ON 状态下才显示 CV/CC 指示

````c
// ...existing code...

// 粗调/精调模式标志
uint8_t voltage_coarse_mode = 0; // 电压粗调模式标志
uint8_t current_coarse_mode = 0; // 电流粗调模式标志

// ON/OFF 状态标志
uint8_t output_enabled = 0; // 输出使能标志: 0=OFF, 1=ON

// DAC相关常量
// ...existing code...
````

接下来修改主循环中的 ON/OFF 开关处理和 CV/CC 指示灯逻辑：

````c
// ...existing code...
  while (1) {
    // 获取当前时间戳
    uint32_t current_time = HAL_GetTick();

    // 高频率扫描键盘
    KEY_Scan();

    // ON/OFF 按键控制 (非阻塞去抖动)
    static uint32_t last_switch_time = 0;
    static uint8_t switch_state = GPIO_PIN_SET;

    uint8_t current_switch =
        HAL_GPIO_ReadPin(on_off_switch_GPIO_Port, on_off_switch_Pin);
    if (current_switch != switch_state) {
      if (current_time - last_switch_time > 20) { // 20ms debounce time
        switch_state = current_switch;
        if (switch_state == GPIO_PIN_RESET) {
          // 切换输出状态
          output_enabled = !output_enabled;
          HAL_GPIO_TogglePin(switch_vcc_GPIO_Port, switch_vcc_Pin);
          
          // OFF 状态下关闭所有指示灯
          if (!output_enabled) {
            HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_RESET);
          }
        }
        last_switch_time = current_time;
      }
    }
    // ...existing code...
````

然后修改 CV/CC 指示灯控制逻辑，使其只在 ON 状态下工作，并正确判断 CV/CC 模式：

````c
// ...existing code...
      // 计算并显示功率
      power_mw = (voltage_mv * current_ma) / 1000.0f;
      if (power_mw > 1000) {
        sprintf(buffer, "P:%.3fW              ", power_mw / 1000.0f);
      } else {
        sprintf(buffer, "P:%.3fmW              ", power_mw);
      }
      OLED_ShowString(0, 18 + 10 * 2, (uint8_t *)buffer, 12, 1);

      // CV/CC 指示灯控制 - 只在 ON 状态下工作
      if (output_enabled) {
        // 计算设定值与实际值的比例
        float voltage_ratio = (SetVoltage > 0.01f) ? (voltage_mv / 1000.0f) / SetVoltage : 0.0f;
        float current_ratio = (SetCurrent > 0.01f) ? (current_ma / 1000.0f) / SetCurrent : 0.0f;
        
        // 判断工作模式:
        // CC模式: 实际电流接近设定电流（电流限制生效）
        // CV模式: 实际电压接近设定电压（电压限制生效）
        // 使用 95% 阈值判断是否达到限制
        uint8_t is_cc_mode = (current_ratio >= 0.95f) && (current_ma > 10.0f); // 电流达到设定值
        uint8_t is_cv_mode = (voltage_ratio >= 0.95f) && (voltage_mv > 100.0f); // 电压达到设定值
        
        if (is_cc_mode && !is_cv_mode) {
          // 恒流模式: CC亮, CV灭
          HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_SET);
          HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_RESET);
        } else if (is_cv_mode && !is_cc_mode) {
          // 恒压模式: CV亮, CC灭
          HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_SET);
          HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_RESET);
        } else if (is_cv_mode && is_cc_mode) {
          // 同时达到限制: 两个都亮
          HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_SET);
          HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_SET);
        } else {
          // 都未达到限制（轻载或无负载）: 只亮CV
          HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_SET);
          HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_RESET);
        }
      } else {
        // OFF 状态: 两个指示灯都关闭
        HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_RESET);
      }

      // 只在非输入状态且编码器未激活时清除提示行
      // ...existing code...
````

同时，修改 DAC 输出更新，使其在 OFF 状态下输出 0：

````c
// ...existing code...
      // 更新DAC输出 - 只在 ON 状态下输出设定值
      int dac_ret;
      if (output_enabled) {
        dac_ret = Update_DAC_Outputs();
      } else {
        // OFF 状态下输出 0V/0A
        int ret_v = DAC60501_SetVoltageOutput(0.0f);
        int ret_i = DAC60501_SetCurrentOutput(0.0f);
        dac_ret = (ret_v != 0 || ret_i != 0) ? -3 : 0;
      }
      
      if (dac_ret == -1) {
        OLED_ShowString(0, 54, (uint8_t *)"V-DAC ERR!       ", 8, 1);
      } else if (dac_ret == -2) {
        OLED_ShowString(0, 54, (uint8_t *)"I-DAC ERR!       ", 8, 1);
      } else if (dac_ret == -3) {
        OLED_ShowString(0, 54, (uint8_t *)"DACs ERR!       ", 8, 1);
      }
      // ...existing code...
````

## 功能说明

1. **ON/OFF 控制**：
   - 按下 ON/OFF 开关切换输出状态
   - OFF 时 DAC 输出 0V/0A，指示灯全灭

2. **CV/CC 模式判断**（仅 ON 状态）：
   - **CC 模式**：实际电流 ≥ 95% 设定电流 → CC_LED 亮
   - **CV 模式**：实际电压 ≥ 95% 设定电压 → CV_LED 亮
   - **轻载/无负载**：默认 CV_LED 亮

---

_**User (2025-11-28 04:05Z)**_

把这个切换输出调整封装一个函数// 切换输出状态
          output_enabled = !output_enabled;
          HAL_GPIO_TogglePin(switch_vcc_LED_GPIO_Port, switch_vcc_LED_Pin);

          // OFF 状态下关闭所有指示灯
          if (!output_enabled) {
            HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_RESET);
          },并且在除了现在on_off_switch_GPIO_Port可以控制外,键盘的key == 'C'也可以控制ON\OFF

---

_**Agent (model copilot/claude-opus-4.5)**_

我将把切换输出功能封装成一个函数，并在 `'C'` 键处理中调用它。

````c
// ...existing code...

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
static void Process_Key_Input(char key);
static void Clear_Input_Buffer(void);
static void Display_Input_Prompt(void);
static uint8_t Validate_And_Set_Value(void);
static void Process_Encoder(void);
static int Update_DAC_Outputs(void);
static void Toggle_Output(void); // 新增：切换输出状态函数声明
/* USER CODE END PFP */

// ...existing code...

/**
 * @brief  切换输出状态 (ON/OFF)
 * @note   切换 output_enabled 标志，控制 LED 指示灯
 */
static void Toggle_Output(void) {
  // 切换输出状态
  output_enabled = !output_enabled;
  HAL_GPIO_TogglePin(switch_vcc_LED_GPIO_Port, switch_vcc_LED_Pin);

  // OFF 状态下关闭所有指示灯
  if (!output_enabled) {
    HAL_GPIO_WritePin(GPIOA, CV_LED_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOA, CC_LED_Pin, GPIO_PIN_RESET);
  }
}

/**
 * @brief  处理按键输入
 * @param  key: 按键字符
 */
static void Process_Key_Input(char key) {
  switch (input_state) {
    // 如果在空闲状态按下时候:
  case INPUT_IDLE:
    if (key == 'A') {
      // 开始输入电压
      input_state = INPUT_VOLTAGE;
      Clear_Input_Buffer();
      encoder_v_active = 0; // 清除编码器状态
      encoder_i_active = 0;
      Display_Input_Prompt();
    } else if (key == 'B') {
      // 开始输入电流
      input_state = INPUT_CURRENT;
      Clear_Input_Buffer();
      encoder_v_active = 0; // 清除编码器状态
      encoder_i_active = 0;
      Display_Input_Prompt();
    } else if (key == 'C') {
      // C键控制ON/OFF切换
      Toggle_Output();
    } else if (key == '*') {
      // 空闲状态下的*键：长按清空，短按无操作
      if (Key_IsLongPress()) {
        SetVoltage = 0.0f;
        SetCurrent = 0.0f;
        OLED_ShowString(0, 54, (uint8_t *)"  --- Clear OK ---       ", 8, 1);
        OLED_Refresh();
        HAL_Delay(1000);
      }
    }
    break;

// ...existing code...
````

然后修改主循环中的开关处理，使用封装的函数：

````c
// ...existing code...
  while (1) {
    // 获取当前时间戳
    uint32_t current_time = HAL_GetTick();

    // 高频率扫描键盘
    KEY_Scan();

    // ON/OFF 按键控制 (非阻塞去抖动)
    static uint32_t last_switch_time = 0;
    static uint8_t switch_state = GPIO_PIN_SET;

    uint8_t current_switch =
        HAL_GPIO_ReadPin(on_off_switch_GPIO_Port, on_off_switch_Pin);
    if (current_switch != switch_state) {
      if (current_time - last_switch_time > 20) { // 20ms debounce time 防抖
        switch_state = current_switch;
        if (switch_state == GPIO_PIN_RESET) {
          // 使用封装的切换函数
          Toggle_Output();
        }
        last_switch_time = current_time;
      }
    }
// ...existing code...
````

## 修改说明

1. **新增 `Toggle_Output()` 函数**：封装了输出状态切换逻辑
2. **`'C'` 键功能**：在空闲状态下按 `'C'` 键可切换 ON/OFF
3. **硬件开关**：保持原有功能，调用同一个封装函数

现在有两种方式控制输出：
- 硬件开关 (`on_off_switch_Pin`)
- 键盘 `'C'` 键

---

